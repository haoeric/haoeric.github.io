---
title: "Monocle_test"
author: "haoeric"
date: "Tuesday, September 16, 2014"
output:
  html_document:
    fig_height: 7
    fig_width: 9
    toc: yes
  pdf_document:
    toc: yes
---

### 1 The CellDataSet class

monocle holds single cell expression data in objects of the **CellDataSet** class. The class is derived from the Bioconductor **ExpressionSet** class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires **three input files**:             

1. **_exprs_**, a numeric matrix of expression values, where rows are genes, and columns are cells
2. **_phenoData_**, an AnnotatedDataFrame object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.)
3. **_featureData_**, an AnnotatedDataFrame object, where rows are features (e.g. genes), and columns are gene attributes, such as biotype, gc content, etc.

### 2 read the data
create a new **CellDataSet** object as follows:
```{r, message=FALSE}
setwd("C:/Users/hchen/Desktop/Single Cell Analysis/data/RNAseq_22Sep2014_fromCJM")
library(monocle)
rpkm_matrix <- read.table("RPKM.txt", header = TRUE, sep = "\t", 
                          stringsAsFactors = FALSE)
rnames <- rpkm_matrix[,1]
rpkm_matrix[,1] <- NULL
rownames(rpkm_matrix) <- rnames
cnames <- colnames(rpkm_matrix)

sample_sheet <- data.frame(cell_id = cnames, Cell.Type = "CDP")
rownames(sample_sheet) <- cnames
gene_ann <- data.frame(gene_short_name = rnames)
rownames(gene_ann) <- rnames
pd <- new("AnnotatedDataFrame", data = sample_sheet)
fd <- new("AnnotatedDataFrame", data = gene_ann)

myCDS <- new("CellDataSet", exprs = as.matrix(rpkm_matrix), phenoData = pd, featureData = fd)

```

It is often convenient to know how many cells express a particular gene, or how many genes are expressed by a given cell. Monocle provides a simple function to compute those statistics `detectGenes`:
```{r}
myCDS <- detectGenes(myCDS, min_expr = 0.1)
print(head(fData(myCDS)))
expressed_genes <- row.names(subset(fData(myCDS), num_cells_expressed >= 200))
```
The vector `expressed_genes` now holds the identifiers for genes expressed in at least 200 cells of the data set. This list can be used later when put the cells in order of biological progress. It is also sometimes convenient to exclude genes expressed in few if any cells from the **CellDataSet** object so as not to waste CPU time analyzing them for differential expression.

### 3 Quality control of single cell RNA-Seq experiments
CellDataSet objects provide a convenient place to store per-cell scoring data: the phenoData slot. Simply include scoring attributes as columns in the data frome you used to create your CellDataSet container. You can then easily filter out cells that don't pass quality control. You might also filter cells based on metrics from high throughput sequencing quality assessment packages such as FastQC. Such tools can often identify RNA-Seq libraries made from heavily degraded RNA, or where the library contains an abnormally large amount of ribosomal, mitochondrial, or other RNA type that you might not be interested in. For example:
```{r}
# valid_cells <- row.names(subset(pData(myCDS), Cells.in.Well == 1 & Control == FALSE & Clump == FALSE & Debris == FALSE & Mapped.Fragments > 1e+06))
valid_cells <- row.names(subset(pData(myCDS), num_genes_expressed >= 3000))
myCDS <- myCDS[expressed_genes, valid_cells]
```
Once you've excluded cells that do not pass your quality control filters, you should verify that the expression values stored in your CellDataSet follow a distribution that is roughly lognormal:
```{r}
# Log-transform each value in the expression matrix.
L <- log(exprs(myCDS))
# Standardize each gene, so that they are all on the same scale, Then melt
# the data with plyr so we can plot it easily 
melted_dens_df <- melt(t(scale(t(L))))
# Plot the distribution of the standardized gene expression values.
qplot(value, geom = "density", data = melted_dens_df) + stat_function(fun = dnorm, size = 0.5, color = "red") + xlab("Standardized log(FPKM)") + ylab("Density")
```

### 4 Differential expression analysis
In many biological processes, cells do not progress in perfect synchrony. In single-cell expression studyies of processes such as cell differentiation, captured cells might be widely distributed in terms of progress. That is, in a population of cells captured at exactly the same time, some cells might be far along, while others might not yet even have begun the process. Monocle can informatically put the cells "in order" of how far they have progressed through the process you're studying. Monocle may even be able to find where cells diverge, with groups of cells proceeding down distinct
paths. First, we must decide which genes we will use to define a cell's progress through myogenesis. Monocle orders cells by examining the pattern of expression of these genes across the cell population. Monocle looks for genes that vary in "interesting" ways (that is aren't just noisy), and uses these to structure the data. We ultimately want a set of genes that increase (or decrease) in expression as a function of progress through the process we're studying. Ideally, we'd like to use as little prior knowledge of the biology of the system under study as possible. We'd like to discover the important ordering genes from the data, rather than relying on literature and textbooks, because that might introduce bias in the ordering. One effective way to isolate a set of ordering genes is to simply compare the cells collected at the beginning of the process to those at the end and find the **differentially expressed genes**, as described above. The command below will find all genes that are differentially expressed in response to the switch from growth medium to differentiation medium:
```{r, eval = FALSE}
diff_test_res <- differentialGeneTest(myCDS)
# Select genes that are significant at an FDR < 10%
ordering_genes <- row.names(subset(diff_test_res, qval < 0.01))
# Once we have a list of gene ids to be used for ordering, we need to set them in the HSMM object, because the next several functions will depend on them.
myCDS <- setOrderingFilter(myCDS, ordering_genes)
```

### 5 Ordering cells by progress
The genes we've chosen to use for ordering define the state space of the cells in our data set. Each cell is a point in this space, which has dimensionality equal to the number of genes we've chosen. So if there are 500 genes used for ordering, each cell is a point in a 500-dimensional space. For a number of reasons, Monocle works better if we can reduce the dimensionality of that space before we try to put the cells in order. In this case, we will reduce the space down to one with two dimensions, which we will be able to easily visualize and interpret while Monocle is ordering the cells.

```{r}
myCDS <- reduceDimension(myCDS, use_irlba = F)
```
                     
Now that the space is reduced, it's time to order the cells. The call below has two important optional arguments. The first `num_paths` allows Monocle to assign cells to one of several alternative fates. In this case, we know there are contaminating fibroblasts in the culture, so by setting `num_paths= 2`, the fibroblasts wind up on their own trajectory in response to the serum switch, instead of getting mixed in with the myoblasts. The second important argument is the `reverse` flag. Monocle won't be able to tell without some help which cells are at the beginning of the process
and which are at the end. The `reverse` flag tells Monocle to reverse the orientation of the entire process as it's being discovered from the data, so that the cells that would have been assigned to the end are instead assigned to the beginning, and so on.
```{r}
myCDS <- orderCells(myCDS, num_paths = 3, reverse = F)
plot_spanning_tree(myCDS)
```

