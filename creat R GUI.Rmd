---
title: "Create R GUI using tcltk"
author: "Chen Hao"
date: "Tuesday, October 07, 2014"
output:
  html_document:
    toc: yes
---

tcltk
========================

### Widgets

A widget is a GUI element. Tk comes with a selection of basic widgets: 

col_1 | col_2 |  col_3 | 
--------- | ---------- | ----------
text editing windows | Sliders | text entry fields 
Buttons | Labels | Menus 
list boxes |canvas for drawing graphics |

Take a look of all the export functions in **tcltk** package.
```{r, eval=FALSE}
library(tcltk)
ls("package:tcltk")
```

These can be combined to form more complex GUI applications.

#### 1. Container widget

+ `tktoplevel()`  top-level window
+ `tkframe()`  Underlying frame container

1.1 __top-level window__
```{r, eval=FALSE}
library(tcltk)
tt <- tktoplevel()
tt <- tktoplevel(bg="white", width=200, height=190)
```

The title of the window is "1" by default. To set a different title, use
```{r, eval=FALSE}
tktitle(tt) <- "My window"
```

or 
```{r, eval=FALSE}
window <- tktoplevel ()
tkwm.title(window , "My window")
frame <- ttkframe(window , padding = c(3 ,3 ,12 ,12)) 
tkpack ( frame , expand = TRUE , fill = "both" )
```

In our example, the top-level window has a frame immediately packed inside of it through the commands. The arguments to tkpack are given so that the frame, will expand and fill all the space allocated by the top-level window. As the top- level window is not a themed widget, not doing this can leave odd-looking effects.

1.2 __underlying frame container__
```{r, eval=FALSE}
one <- tkframe(tt, bg = "white")
two <- tkframe(tt, width = 100, height = 50, bg = "grey50")
for(b in c("alpha", "beta", "gamma")) {
    assign(b, tkbutton(one, text = b))
    tkpack(get(b), side = "left")
}
tkpack(one, two, side = "top")
```

Several widgets can be packed into the same container, which is the key to constructing complex applications out of elementary building blocks.

#### 2. Other constructor widgets

+ `tklabel()`  arguments: parent container, anchor, background, font, foreground, justify, padding, relief, text, and wraplength.
+ `tkentry()`
+ `tkbutton()`  Button widgets are used to initiate some action or command, and the command option is used to specify this.
+ `tkradiobutton()`
+ `tkmessageBox()`
+ `tkcheckbutton()`
+ `tklistbok()`
+ `tkmenu()`
+ `tkadd()`
+ `tkchooseDirectory()`
+ `tk_choose.files()`

the construction of widgets in tcltk is linked to the widget hierarchy. Tk widgets are constructed as children of a parent object, with the parent specified to the constructor.

2.1 Demo 1
```{r, eval=FALSE}
edge <- c("top","right","bottom","left")
buttons <- lapply(1:4, function(i) tkbutton(tt, text=edge[i]))
for ( i in 1:4 ){
    tkpack(buttons[[i]], side=edge[i], fill="both")
}
```

2.2 Demo 2
```{r,eval=FALSE}
tt <- tktoplevel()
rb1 <- tkradiobutton(tt)
rb2 <- tkradiobutton(tt)
rbValue <- tclVar("import")
tkconfigure(rb1,variable=rbValue,value="import")
tkconfigure(rb2,variable=rbValue,value="random")
tkgrid(tklabel(tt,text="Which kind of data set?"), columnspan=5)
tkgrid(tklabel(tt,text="Import"),rb1)
tkgrid(tklabel(tt,text="Random"),rb2)
done <- tclVar(0)
OnOK <- function() {
    Data <<- as.character(tclvalue(rbValue))
    tclvalue(done)<-1
    tkdestroy(tt)
}
OK.but <- tkbutton(tt,text="OK",command=OnOK)
tkgrid(OK.but,row=4, column=3)
tkwait.variable(done)
```

2.3 Demo 3
```{r, eval=FALSE}
# message box
ReturnVal <- tkmessageBox(title = "Help", message = Help5, icon = "info", type = "ok")
# check button
Bnex <- tkcheckbutton(one)
# list box
maliste<-tklistbox(tt, height=7, selectmode="single", background="white")
# Menu
topMenu <- tkmenu(tt)
fileMenu <- tkmenu(topMenu, tearoff=FALSE)
tkadd(topMenu,"cascade", label="Fichiers", menu=fileMenu)
```

A widget along the top or bottom is allocated a parcel just high enough to contain the widget, but occupying as much of the width of the container as possible, whereas widgets along the sides get a parcel of maximal height, but just wide enough to contain it.

### Geometry managers

A geometry manager controls the placement of slave widgets within a master widget. Three different geometry managers are available in Tcl/Tk. The simplest one is called the **placer** and is almost never used. The others are the **packer** and the **grid manager**.

+ `tkpack()`
+ `tkgrid()`
+ `tkconfigure`  

1. **packer**: packs widgets in order around edges of cavity. Notice that there is a *packing order* and a *packing direction*.

```{r, eval=FALSE}
edge <- c("top","right","bottom","left")
buttons <- lapply(1:4, function(i) tkbutton(tt, text=edge[i]))
for ( i in 1:4 ){
    tkpack(buttons[[i]], side=edge[i], fill="both")
}
```

```{r, eval=FALSE}
one <- tkframe(tt, width = 40, height = 40, bg = "white")
two <- tkframe(tt, width = 100, height = 100, bg = "grey50")
tkpack.propagate(tt, FALSE) ## Window wont resize
tkpack(one, two, side = "top")
```

**packing order**   `side`: "top", "right", "bottom", "left"            
**packing direction**   `fill`: "x", "y", "both"              
**expands as much as possible**    `expand`: TRUE, FALSE             
**anchoring**    `anchor`: "n", "ne", "e", "se", "s", "sw", "w" and "nw"         

A widget along the top or bottom is allocated a parcel just high enough to contain the widget, but occupying as much of the width of the container as possible, whereas widgets along the sides get a parcel of maximal height, but just wide enough to contain it.               

If a widget is left with more packing space than display space, you can position it within its packing space using the anchor packing option. The default anchor position is center. The other options correspond to points on a compass: n, ne, e, se, s, sw, w and nw.



2. **grid manager**: it lays out widgets in rows and columns.

```{r, eval=FALSE}
t2 <- tktoplevel()
heading <- tklabel(t2, text="Registration form")
l.name <- tklabel(t2, text="Name")
l.age <- tklabel(t2, text="Age")
e.name <- tkentry(t2, width=30)
e.age <- tkentry(t2, width=3)
tkgrid(heading, columnspan=2)
tkgrid(l.name, e.name)
tkgrid(l.age, e.age)
tkgrid.configure(e.name, e.age, sticky="w")
tkgrid.configure(l.name, l.age, sticky="e")
```


```{r, eval=FALSE}
tt <- tktoplevel()
titlepolice <- tkfont.create(size=10, weight="bold")
titlegw<-tklabel(tt, text="Gap weighting (nexus)")
tkconfigure(titlegw,font=titlepolice)
lablistgw<-tklabel(tt, text="One or more value(s) for the number of states separated by a comma")
OR<-tklabel(tt,text="Or")
labseqgwF<-tklabel(tt, text="from")
labseqgwT<-tklabel(tt, text="to")
labseqgwB<-tklabel(tt, text="by")
listgw<-tkentry(tt, width=20)
gwF<-tkentry(tt, width=6)
gwT<-tkentry(tt, width=6)
gwB<-tkentry(tt, width=6)
tkgrid(titlegw, row=0, columnspan=6,sticky="w")
tkgrid(lablistgw, row=1, column=0, sticky="w",columnspan=10)
tkgrid(listgw, row=1, column=11, sticky="w")
tkgrid(OR,row=2, column=0, sticky="w")
tkgrid(labseqgwF, row=2, column=1, sticky="w")
tkgrid(gwF, row=2, column=2, sticky="w")
tkgrid(labseqgwT, row=2, column=3, sticky="w")
tkgrid(gwT, row=2, column=4, sticky="w")
tkgrid(labseqgwB, row=2, column=5, sticky="w")
tkgrid(gwB, row=2, column=6, sticky="w")
```


The `columnspan` argument joins grid cells horizontally. The `sticky` argument works somewhat like anchoring in the packer. The value can be any subset of n, s, e, and w and specifies that the widget should stick to the specified sides of the cell.


3. **tkconfigure**: It adjusts the parameters of a constructor widget.  Colors can be specified by name – for common colors – or by hex RGB values which are common in web programming


### Communication with widgets

We need a way to get data from widgets to and from R, and a way to make things happen in response to widget events. There are two general patterns for this, namely **control variables** and **callbacks**.

+ `tclVar`

```{r, eval=FALSE}
text_var <- tclVar ( "" )
entry <- ttkentry ( g , textvariable = text_var )
```

The first line defines a new object of class `tclVal` which is used for the textvariable option when defining the entry widget. This variable is dy- namically bound to the widget, so that changes to the variable are prop- agated to the GUI. (The Tcl variable is a model and the widget a view of the model.) The Tcl variable can be used with more than one widget, allowing a simple form of synchronization. The basic functions involved are tclVar to create a Tcl variable, tclvalue to get the assigned value, and tclvalue<- to modify the value.


+ `tclArray`

```{r, eval=FALSE}
x <- tclArray()
x$one <- 1
x[[2]] <- 2 
x[[1]]      # return NULL
x[['one']]  # return 1
x[['2']]    # return 2
```

`tclArray` to store an array of Tcl variables. The usual list methods like [[ and $ and their forms for assignment are available for arrays, but values are referred to only by name, not index.